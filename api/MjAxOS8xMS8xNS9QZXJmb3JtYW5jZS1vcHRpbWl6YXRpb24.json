{"title":"性能优化","date":"2019-11-15T11:40:02.668Z","thumbnail":"https://s2.ax1x.com/2019/11/15/MaqZQS.md.jpg","link":"2019/11/15/Performance-optimization","updated":"2019-11-17T11:49:03.892Z","content":"<h2 id=\"页面加载和渲染\">页面加载和渲染<a href=\"2019/11/15/Performance-optimization#页面加载和渲染\"></a></h2><ul>\n<li><p>从输入URL到渲染出整个页面的过程：</p>\n<ul>\n<li><p>加载过程：</p>\n<ul>\n<li>DNS解析：域名 -&gt; IP地址</li>\n<li>浏览器根据IP地址向服务器发起Http请求</li>\n<li>服务处理Http请求，并返回给浏览器</li>\n</ul>\n</li>\n<li><p>渲染过程</p>\n<ul>\n<li><p>根据HTML代码生成DOM Tree</p>\n</li>\n<li><p>根据CSS代码生成CSSOM</p>\n</li>\n<li><p>将DOM Tree和CSSOM整合形成Render Tree</p>\n</li>\n<li><p>根据Render Tree渲染页面</p>\n</li>\n<li><p>遇到<code>&lt;script&gt;</code>则暂停渲染，优先加载并执行JS代码，完成后再继续</p>\n</li>\n<li><p>直至把Render Tree渲染完成</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>CSS应该放在head标签内，JS应该放在body最后</p>\n<p>前者是为了防止渲染的过程中Render Tree发生改变，得重新渲染；后者是为了让页面尽快呈现出来，减少用户等待时间。</p>\n</li>\n</ul>\n<ul>\n<li><p><code>window.onload</code>和<code>DOMContentLoaded</code>的区别</p>\n<p>前者得等页面全部资源加载完才会执行，包括视频、图片;</p>\n<p>后者在DOM渲染完成后就能执行，此时图片、视频等可能为加载完成4</p>\n</li>\n</ul>\n<h2 id=\"性能优化原则\">性能优化原则<a href=\"2019/11/15/Performance-optimization#性能优化原则\"></a></h2><ul>\n<li>多使用内存、缓存或者其他方法</li>\n<li>减少CPU计算量，减少网络加载耗时</li>\n<li>本质都是空间换时间</li>\n</ul>\n<h2 id=\"性能优化的方向\">性能优化的方向<a href=\"2019/11/15/Performance-optimization#性能优化的方向\"></a></h2><ul>\n<li>让加载更快<ul>\n<li>减少资源体积：压缩代码</li>\n<li>减少访问次数：合并代码，SSR服务器端渲染，缓存</li>\n<li>使用更快的网络：CDN</li>\n</ul>\n</li>\n<li>让渲染更快<ul>\n<li>CSS放在head中，JS放在body的最下面</li>\n<li>尽早开始执行JS，用<code>DOMContentLoaded</code>触发</li>\n<li>懒加载（图片懒加载，上滑显示更多）</li>\n<li>对DOM查询进行缓存</li>\n<li>频繁DOM操作，合并在一起再插入DOM结构</li>\n<li>节流（throttle）、防抖（debounce）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"SSR\">SSR<a href=\"2019/11/15/Performance-optimization#SSR\"></a></h3><ul>\n<li>服务器端渲染：将网页和数据一起加载，一起渲染</li>\n<li>非SSR（前后端分离）：先加载网页，再请求数据，再渲染数据</li>\n</ul>\n<h3 id=\"懒加载\">懒加载<a href=\"2019/11/15/Performance-optimization#懒加载\"></a></h3><ul>\n<li><p>图片懒加载</p>\n<figure class=\"highlight html\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">id</span>=<span class=\"string\">\"img1\"</span> <span class=\"attr\">src</span>=<span class=\"string\">\"preview.png\"</span> <span class=\"attr\">data-realsrc</span>=<span class=\"string\">\"abc.png\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  let img1 = document.getElementById('img1')</span><br><span class=\"line\">  img1.src = img1.getAttribute('data-realsrc')</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></div></figure>\n\n\n\n</li>\n</ul>\n<h3 id=\"防抖\">防抖<a href=\"2019/11/15/Performance-optimization#防抖\"></a></h3><p>业务场景：监听一个输入框的文字变化后，触发change事件。直接用keyup事件，会频繁的触发change事件。而防抖则是用户输入结束或者暂停时，才会触发change事件。 </p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 防抖</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, delay = <span class=\"number\">500</span></span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">      clearTimeout(timer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">      clearTimeout(timer)</span><br><span class=\"line\">    &#125;, delay)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> input1 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'input1'</span>)</span><br><span class=\"line\">input1.addEventListener(<span class=\"string\">'keyup'</span>, debounce(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(input1.value)</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></div></figure>\n\n<h3 id=\"节流\">节流<a href=\"2019/11/15/Performance-optimization#节流\"></a></h3><p>业务场景：拖拽一个元素，要随时拿到该元素被拖拽的位置。直接用drag事件，则会频发的触发，很容易导致卡顿。而节流则是无论比拖拽多快，都会每隔一个固定事件触发一次。</p>\n<figure class=\"highlight javascript\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">fn ,delay = <span class=\"number\">100</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    timer = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">      timer = <span class=\"literal\">null</span></span><br><span class=\"line\">    &#125;, delay);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> div1 = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'div1'</span>)</span><br><span class=\"line\">div1.addEventListener(<span class=\"string\">'drag'</span>, throttle( <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.offsetX, e.offsetY)</span><br><span class=\"line\">&#125;, <span class=\"number\">200</span>))</span><br></pre></td></tr></table></div></figure>\n\n","prev":{"title":"JavaScript —— 安全","link":"2019/11/17/safety"},"next":{"title":"简单的webpack配置","link":"2019/11/15/webpack"},"plink":"http://yoursite.com/2019/11/15/Performance-optimization/","toc":[{"title":"页面加载和渲染","id":"页面加载和渲染","index":"1"},{"title":"性能优化原则","id":"性能优化原则","index":"2"},{"title":"性能优化的方向","id":"性能优化的方向","index":"3","children":[{"title":"SSR","id":"SSR","index":"3.1"},{"title":"懒加载","id":"懒加载","index":"3.2"},{"title":"防抖","id":"防抖","index":"3.3"},{"title":"节流","id":"节流","index":"3.4"}]}]}